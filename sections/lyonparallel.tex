LyonParallel is a prototype tool, written in OCaml, for the analysis of DPO graph rewriting systems.
It implements the type graph method presented in~\cite{endrullis2024generalized_icgt} and its extension in Chapter~\ref{chap:nwf}, the morphism counting method in Chapter~\ref{chap:subgraph_counting} and its extension in Chapter~\ref{chap:antipattern}. Note that the type graph method presented in~\cite{endrullis2024generalized_icgt} is more powerful than the versions presented in~\cite{zantema2014termination,bruggink2014termination,bruggink2015proving}, which are implemented in~\cite{TORPAcyc} and~\cite{grez}, for DPO graph rewriting systems with monic match. This method does not have a publicly available implementation. 

LyonParallel implements the notions of DPO rewriting systems on finite directed, edge-labeled multigraphs introduced in Chapter~\ref{chap:preliminaries}. Using the \texttt{REPL} (Read-Eval-Print Loop)\textemdash an interactive environment that reads user commands, evaluates them, prints results, and waits for the next input\textemdash users can select a set of rules encoded in the tool, then choose a method to partition the rules of the system into two sets $\mathcal{A}$ and $\mathcal{B}$ such that $\mathcal{A}$ terminates relative to $\mathcal{B}$. If such a partition is found, the tool replaces the current rule set with \(\mathcal{B}\) and a new iteration begins; otherwise users may try a different method. When the rule set becomes empty, the termination of the original system is proven.
\section{DPO graph rewriting systems on finite directed edge-labeled multigraphs}
\label{lyonparallel:sec:implementation_of_dpo_graph_rewriting_systems}
A \textbf{labeled graph} is encoded in the tool as a structure with five fields: a list of nodes, a list of edges, a mapping that associates to each edge a source node, a mapping that associates to each edge a target node, and a mapping that associates to each edge a label.
The representation of a labeled graph is constructed using the function \colorbox{Ivory2}{$MGraph.fromList$} given 2 parameters. The first parameter is a list of integers representing the nodes of the graph. The second parameter is a list of four-tuples representing the labeled edges of the graph, where each tuple \colorbox{Ivory2}{$(s,lab,t,id)$} of type \colorbox{Ivory2}{$\textit{int}\times \textit{string}\times \textit{int}\times \textit{int}$} represents an edge with source node $s$, label $lab$, target node $t$, and identifier $id$.

For example, consider graphs $K$,$L$, and $R$ shown in Figure~\ref{fig:implemented:grsaa_0}.
\begin{figure}[H]
      \centering 
      \resizebox{0.8\textwidth}{!}{
      \begin{tikzpicture}
          \graphbox{$L$}{0mm}{0mm}{34mm}{15mm}{2mm}{-5mm}{
              \coordinate (o) at (0mm,-3mm); 
              \node[draw,circle] (l1) at ($(o)+(-10mm,0mm)$) {1};
              \node[draw,circle] (l2) at ($(l1)+(2,0)$) {2};
              \node[draw,circle] (l3) at ($(l1)+(1,0)$) {3};
              \draw[->] (l1) -- (l3) node[midway,above] {$a$};
              \draw[->] (l3) -- (l2) node[midway,above] {$a$};
          }     
          \graphbox{$K$}{40mm}{0mm}{24mm}{15mm}{2mm}{-5mm}{
              \coordinate (o) at (5mm,-3mm); 
              \node[draw,circle] (l1) at ($(o)+(-10mm,0mm)$) {1};
              \node[draw,circle] (l2) at ($(l1)+(1,0)$) {2};
              % \node[draw,circle] (l3) at ($(l1)+(1,0)$) {$\ $};
              % \draw[->] (l1) -- (l3) node[midway,above] {$a$};
              % \draw[->] (l3) -- (l2) node[midway,above] {$a$};
          }    
          \graphbox{$R$}{70mm}{0mm}{45mm}{15mm}{2mm}{-5mm}{
              \coordinate (o) at (-5mm,-3mm); 
              \node[draw,circle] (l1) at ($(o)+(-10mm,0mm)$) {1};
              \node[draw,circle] (l2) at ($(l1)+(3,0)$) {2};
              \node[draw,circle] (l3) at ($(l1)+(1,0)$) {4};
              \node[draw,circle] (l4) at ($(l1)+(2,0)$) {5};
              \draw[->] (l1) -- (l3) node[midway,above] {$a$};
              \draw[->] (l3) -- (l4) node[midway,above] {$b$};
              \draw[->] (l4) -- (l2) node[midway,above] {$a$};
          }    
          \node () at (37mm,-8mm) {$\overset{l}{\leftarrowtail}$};
          \node () at (67mm,-8mm) {$\overset{r}{\rightarrowtail}$};
          % \draw[>->] (51mm,2mm) -- (52mm,3mm);
      \end{tikzpicture}
      }
      \caption{}
      \label{fig:implemented:grsaa_0}
  \end{figure}
Their representation in OCaml can be constructed by the following code:
\begin{minted}{ocaml}
    let graph_K \mathop{=} MGraph.fromList [1;2] []
    let graph_L \mathop{=} Mgraph.fromList [1;2;3] 
                    [(1,"a",3,1);(3,"a",2,2)]
    let graph_R \mathop{=} Mgraph.fromList [1;2;4;5] 
                    [(1,"a",4,1);(4,"b",5,2);(5,"a",2,3)]
\end{minted}

A \textbf{homomorphism} between two labeled graphs is encoded as a mapping from the nodes of the source graph to the nodes of the target graph, which preserves the edge labels and the source and target nodes of each edge. Its representation can be constructed using the function
\colorbox{Ivory2}{$GraphHomomorphism.fromList$}, given 4 arguments:
    \begin{enumerate}
        \item the first argument is the source graph,
        \item the second argument is the target graph,
        \item the third argument is a list of pairs, where each pair $(s,t)$ means that node $s$ of the source graph is mapped to node $t$ of the target graph,
        \item the fourth argument is a list of pairs similar to the third argument, but for the edges.
    \end{enumerate}
For example, consider morphisms $l$ and $r$ shown in Figure~\ref{fig:implemented:grsaa_0}. Their representation in OCaml can be constructed using the following code:
\begin{minted}{ocaml}
    let morphism_l \mathop{=} GraphHomomorphism.fromList 
                        graph_K graph_L [(1,1);(2,2)] []
    let morphism_r \mathop{=} GraphHomomorphism.fromList
                        graph_K graph_R [(1,1);(2,2)] []
\end{minted}

A DPO \textbf{rewriting rule} is represented by a structure with two fields: a left-hand-side homomorphism and a right-hand side homomorphism. The representation of a rewriting rule can be constructed using the function
 $$\colorbox{Ivory2}{$GraphRewritingSystem.DPOrule.fromHomos$}$$
given the representations of the left- and right-hand side homomorphisms.
For example, the representation of the rewriting rule, previously presented and illustrated in Figure~\ref{fig:implemented:grsaa_0}, is constructed using the following OCaml expression, which creates the representation of a DPO rule from the representations of the left and right morphisms: 
\begin{minted}{ocaml}
    let rl \mathop{=} GraphRewritingSystem.DPOrule.fromHomos 
                morphism_l morphism_r
\end{minted}

A DPO graph \textbf{rewriting system} is represented by a structure with three fields: the set of rules, the name of the system, and a Boolean indicating whether the system is restricted to monic matches. A representation of the DPO graph rewriting system
can be constructed using the function 
$$\colorbox{Ivory2}{$GraphRewritingSystem.fromRulesListAndName$}$$ given three arguments: a list of rewriting rules and the name of the system; the third parameter is \colorbox{Ivory2}{$false$} by default.

For example, the DPO graph rewriting system that contains the single rule, previously presented and illustrated in Figure~\ref{fig:implemented:grsaa_0}, is represented by the following OCaml expression. 
\begin{minted}{ocaml}
    let bruggink14_ex_4_and_6 =
        GraphRewritingSystem.fromRulesListAndName 
            [rl] "bruggink14_ex_4_and_6"
\end{minted}
The function \colorbox{Ivory2}{$GraphRewritingSystem.fromRulesListAndName$} produces a system named \colorbox{Ivory2}{$bruggink14\_ex\_4\_and\_6$} from the singleton list \colorbox{Ivory2}{$[rl]$}.


\textbf{User-defined rewriting systems} should be placed in the file 
    $$\colorbox{Ivory2}{$lib/concretGraphRewritingSystems.ml$}$$
 To expose them, add each instance to the list 
 $$\colorbox{Ivory2}{$available\_graph\_rewriting\_systems$}$$ in the same file.

For example, for the rewriting rule named \colorbox{Ivory2}{$bruggink14\_ex\_4\_and\_6$}, the following code should be added to the end of the file:
\begin{minted}{ocaml}
    let available_graph_rewriting_systems \mathop{=} 
        bruggink14_ex_4_and_6 :: available_graph_rewriting_systems 
\end{minted}

\section{Ruler-Graphs}
A ruler-graph with one forbidden context as defined in Chapter~\ref{chap:antipattern} is represented by a structure with an underlying graph $X$ and an injective graph homomorphism from $X$. 
Consider a ruler graph $(X, f)$ where $X$ is graph \raisebox{2pt}{
            \scalebox{0.7}{\tikz[baseline=-0.5ex]{
            \node [draw,circle] (z) at (-1,0) {};
            \node [draw,circle] (x) at (0,0) {};
            \node[draw,circle] (y) at (1,0) {};
            \draw[->] (z)--(x) node[midway, above] {$a$};
            \draw[->] (x)--(y) node[midway, above] {$a$};
        }}} 
and the injective graph homomorphism is shown below:
%  in Figure~\ref{fig:intro:graph_transformation_rule_anti_patternsfs}.
%  \begin{figure}[H]
%     \centering
\begin{center}
    \resizebox{0.6\textwidth}{!}{
\begin{tikzpicture}
      \graphbox{$L$}{30mm}{0mm}{34mm}{20mm}{2mm}{-5mm}{
          \coordinate (o) at (0mm,-3mm); 
          \node[draw,circle] (l1) at ($(o)+(-10mm,0mm)$) {1};
          \node[draw,circle] (l2) at ($(l1)+(2,0)$) {2};
          \node[draw,circle] (l3) at ($(l1)+(1,0)$) {3};
          \draw[->] (l1) -- (l3) node[midway,above] {$a$};
          \draw[->] (l3) -- (l2) node[midway,above] {$a$};
      }        
      \graphbox{$F$}{70mm}{0mm}{45mm}{20mm}{2mm}{-5mm}{
        \coordinate (o) at (0mm,-3mm); 
        \node[draw,circle] (l1) at ($(o)+(-10mm,0mm)$) {1};
        \node[draw,circle] (l2) at ($(l1)+(2,0)$) {2};
        \node[draw,circle] (l3) at ($(l1)+(1,0)$) {3};
        \draw[->] (l1) -- (l3) node[midway,above] {$a$};
        \draw[->] (l3) -- (l2) node[midway,above] {$a$};
        \draw[->] (l3) edge [loop below] node {$c$} (l3);
      }    
    %   \node () at (37mm,-10mm) {$\leftarrowtail$};
      \node () at (67mm,-10mm) {$\rightarrowtail$};
  \end{tikzpicture}
    }
%   \caption{}
%   \label{fig:intro:graph_transformation_rule_anti_patternsfs}
%  \end{figure} 
\end{center}
Its representation in OCaml
        can be constructed using the following code:
\begin{figure}[H]
\begin{minted}{ocaml} 
    let graph_X \mathop{=} MGraph.fromList 
                    [1;2;3] [(1,"a",3,1);(3,"a",2,2)]
    let ruler_graph_aa_notin_aca \mathop{=} 
        let graph_F \mathop{=} MGraph.fromList 
                [1;2;3] [(1,"a",3,1);(3,"c",3,3);(3,"a",2,2)] in
        let f \mathop{=} Homo.fromList graph_X graph_F 
                    [(1,1);(2,2);(3,3)] [(1,1);(2,2)] in
        {x: graph_X; fx \mathop{=} Some f}
\end{minted}
    \caption{}
    \label{fig:implemented:ruler_graph_representation}
\end{figure}

Instances of ruler-graphs can be defined in the file \colorbox{Ivory2}{$lib/ruler\_graph.ml$} of \textbf{LyonParallel}. To expose these instances to the REPL, they should be added to the list \colorbox{Ivory2}{$ruler\_graphs$} in the same file. For example, for the instance of ruler-graph \colorbox{Ivory2}{$ruler\_graph\_aa\_notin\_aca$} shown in Figure~\ref{fig:implemented:ruler_graph_representation}, the following code should be added to the end of the file:
\begin{minted}{ocaml}
    let ruler_graphs \mathop{=} ruler_graph_aa_notin_aca :: ruler_graphs 
\end{minted}

% As another example, the representation of graph \raisebox{2pt}{
%             \scalebox{0.7}{\tikz[baseline=-0.5ex]{
%             \node [draw,circle] (z) at (-1,0) {};
%             \node [draw,circle] (x) at (0,0) {};
%             \node[draw,circle] (y) at (1,0) {};
%             \draw[->] (z)--(x) node[midway, above] {$a$};
%             \draw[->] (x) edge[loop above] node {$c$} (x);
%             \draw[->] (x)--(y) node[midway, above] {$a$};
%         }}}
%    is constructed using the following code:
% \begin{minted}{ocaml}
%     let y \mathop{=} MGraph.fromList [1;2;3] [(1,"a",3,1);(3,"c",3,3);(3,"a",2,2)]
% \end{minted}

% For example, the ruler-graph with underlying graph \raisebox{2pt}{
%             \scalebox{0.7}{\tikz[baseline=-0.5ex]{
%             \node [draw,circle] (z) at (-1,0) {};
%             \node [draw,circle] (x) at (0,0) {};
%             \node[draw,circle] (y) at (1,0) {};
%             \draw[->] (z)--(x) node[midway, above] {$a$};
%             \draw[->] (x)--(y) node[midway, above] {$a$};
%         }}} and forbidden context \raisebox{2pt}{
%             \scalebox{0.7}{\tikz[baseline=-0.5ex]{
%             \node [draw,circle] (z) at (-1,0) {};
%             \node [draw,circle] (x) at (0,0) {};
%             \node[draw,circle] (y) at (1,0) {};
%             \draw[->] (z)--(x) node[midway, above] {$a$};
%             \draw[->] (x) edge[loop above] node {$c$} (x);
%             \draw[->] (x)--(y) node[midway, above] {$a$};
%         }}} is encoded as the following ocaml structure in the file \mintinline{latex}{Parallel/lib/ruler_graph.ml} of \textbf{LyonParallel}:
% \begin{figure}[H]
%     \begin{minted}{ocaml}
%     let aa_not_in_aca \mathop{=}   
%         let x \mathop{=} MGraph.fromList [1;2;3] [(1,"a",3,1);(3,"a",2,2)] in
%         let f \mathop{=} Homo.fromList 
%             [1;2;3] [(1,"a",3,1);(3,"a",2,2)]
%             [1;2;3] [(1,"a",3,1);(3,"c",3,3);(3,"a",2,2)]
%             [(1,1);(2,2);(3,3)] [(1,1);(2,2)]  in
%         {x; fx \mathop{=} Some f}
%     \end{minted}
%     \caption{}
%     \label{fig:implemented:aa_not_in_aca}
% \end{figure}

\section{Installation and Execution of LyonParallel}
\label{lyonparallel:sec:installation}
This section shows the installation process using \colorbox{Ivory2}{OPAM}\textemdash a package manager for OCaml. To install LyonParallel, one needs to have \colorbox{Ivory2}{OPAM} installed on one's system, then 
run the following command
\begin{minted}[style=bw]{bash}
    >> opam switch create lyonParallel 5.2.1
\end{minted}
    % \colorbox{Ivory2}{opam switch create lyonParallel 5.2.1}
 and follow the instructions to create and switch to a new \colorbox{Ivory2}{OPAM} switch. 
 The dependencies of LyonParallel are listed in the file \colorbox{Ivory2}{$LyonParallel.opam$} in the root directory of the project. To install these dependencies, run the following command:
\begin{minted}{bash}
    >> opam install .
\end{minted}
The project can be built and installed by running the following command:
\begin{minted}{bash}
    >> dune build && dune install
\end{minted}
The following command uninstalls the tool:
\begin{minted}{bash}
    >> opam remove LyonParallel
\end{minted}
Finally, the following command launches the interactive REPL of the tool:
\begin{minted}{bash}
    >> LyonParallel
\end{minted}
Upon launching, one should see:
\begin{minted}[style=bw]{bash}
    >> Type "help" for a list of commands.
\end{minted}
\section{Relative Termination Analysis using LyonParallel}
\label{lyonparallel:sec:termination}
The LyonParallel REPL lets the user select a set of rewriting rules and run the tool's relative termination analysis techniques to test whether the set can be partitioned into two subsets \(\mathcal{A}\) and \(\mathcal{B}\) such that \(\mathcal{A}\) terminates relative to \(\mathcal{B}\). If such a partition is found, the REPL replaces the analyzed rule set with \(\mathcal{B}\) for further analysis; otherwise, the user can try alternative methods or different partitions.

The REPL command \colorbox{Ivory2}{$systems$} lists the available DPO graph rewriting systems; user-defined systems can be added as described in~\textsection~\ref{lyonparallel:sec:implementation_of_dpo_graph_rewriting_systems}. The predefined system shown in Figure~\ref{fig:implemented:grsaa_0} is named \colorbox{Ivory2}{$bruggink14\_ex\_4\_and\_6$} and appears in that list. Select it at the REPL by name:
\begin{minted}[style=bw]{bash}
select_system_by_name bruggink14_ex_4_and_6
\end{minted}


\subsection{Termination Analysis using the Morphism Counting Method}
Consider the graph rewriting system presented in Example~\ref{subgraph_counting:ex_contrib_variant} whose termination cannot be proven using existing interpretation-based approaches. Its unique rule is illustrated below:
%  in Figure~\ref{fig:subgraph_counting:ex_confdkjfakljlfdsfsdfs}.
    % \begin{figure}[H]
    %     \centering
    \begin{center}
        \resizebox{0.7\textwidth}{!}{
            \begin{tikzpicture}
                \graphbox{$L$}{0mm}{0mm}{35mm}{35mm}{2mm}{-5mm}{
                    \coordinate (delta) at (0,-18mm);
                    \node[draw,circle] (l1) at ($(delta)+(-1,1.5)$) {1};
                    \node[draw,circle] (l2) at ($(delta)+(1,1.5)$) {2};
                    \node[draw,circle] (l3) at ($(delta)+(0,0)$) {3};
                    \draw[->] (l1) -- (l3) node[midway,left] {$s$};
                    \draw[->] (l2) -- (l3) node[midway,right] {$s$};
                    \draw[->] (l3) edge [loop below] node {0} (l3);
                }
                \graphbox{$K$}{40mm}{0mm}{35mm}{35mm}{2mm}{-5mm}{
                    \coordinate (delta) at (0,-18mm);
                    \coordinate (interfaceorigin) at ($(delta) +(5,0)$);
                    \node[draw,circle] (r1) at ($(delta) +(-1,1.5)$) {1};
                    \node[draw,circle] (r2) at ($(delta) +(0.5,1.5)$) {2};
                    \node[draw,circle] (r3) at ($(delta)+(0,0)$) {3};
                    % \draw[->] (r1) -- (r3) node[midway,left] {$s$};
                    % \draw[->] (r3) edge [loop below] node {0} (r3);
                }
                \graphbox{$R$}{80mm}{0mm}{50mm}{35mm}{2mm}{-5mm}{
                    \coordinate (delta) at (-10mm,-18mm);
                    \node[draw,circle] (r1) at ($(delta)+(-1,1.5)$) {1};
                    \node[draw,circle] (r2) at ($(delta)+(0.5,1.5)$) {2};
                    \node[draw,circle] (r3) at ($(delta)+(0,0)$) {3};
                    \node[draw,circle] (r4) at ($(delta)+(1,0)$) {4};
                    \draw[->] (r1) -- (r3) node[midway,left] {$s$};
                    \draw[->] (r2) -- (r4) node[midway,right] {$s$};
                    \draw[->] (r4) edge [loop below] node {0} (r4);
                    \draw[->] (r3) edge [loop below] node {0} (r3);
                    \node[draw,circle] (r5) at ($(r2)+(1.5,0)$) {};
                    \draw[->] (r5) edge [loop below] node {0} (r5);
                    \draw[->] (r5) edge [loop right] node {0} (r5);
                    \draw[->] (r5) edge [loop left] node {0} (r5);
                }
                % \graphbox{$R_x$}{40mm}{40mm}{35mm}{35mm}{2mm}{-5mm}{
                %     \coordinate (delta) at (0,-18mm);
                %     \coordinate (rxorigin) at ($(interfaceorigin)+(0,6)$);
                %     \node[draw,circle] (r1) at ($(delta)+(-1,1.5)$) {1};
                %     \node[draw,circle] (r2) at ($(delta)\mathop{+} (0.5,1.5)$) {2};
                %     \node[draw,circle] (r3) at ($(delta)\mathop{+} (0,0)$) {3};
                %     \draw[->] (r1) -- (r3) node[midway,left] {$s$};
                %     % \draw[->] (r3) edge [loop below] node {0} (r3);
                % }
                \node () at (38mm,-18mm) {$\leftarrowtail$};
                \node () at (77mm,-18mm) {$\rightarrowtail$};
                % \node () at (57mm,2mm) {$\uparrowtail$};
                % \node () at (38mm,2mm) {$\swarrowtail$};
                % \node () at (79mm,2mm) {$\searrowtail$};
            \end{tikzpicture}
            }
    %         \caption{}
    %         \label{fig:subgraph_counting:ex_confdkjfakljlfdsfsdfs}
    % \end{figure}
        \end{center}

The following sequence of commands selects the system, then use the morphism counting method without forbidden patterns presented in Chapter~\ref{chap:subgraph_counting} to analyse the relative termination of the system.
\begin{minted}[style=bw]{bash}
    >> select_system_by_name plump18_ex6_rule_copy_variant
    >> subgraph_counting_no_forbidden_context
\end{minted}
The following command summarizes the result of the termination analysis.
 \begin{minted}[style=bw]{bash}
    >> recap
\end{minted}

The message displayed contains \colorbox{Ivory2}{$Terminating:\ yes$} when the method has proved the rule's relative termination with respect to the empty set; otherwise, the message contains \colorbox{Ivory2}{$Terminating:\ unknown$} and \colorbox{Ivory2}{$Remaining\ Rules:$}, followed by a list of rules to be analyzed.

Our implementation automatically tries every subgraph of the left-hand-side graphs of the system's rules as a candidate rule-graph until one succeeds. The chosen rule graph is then displayed in the analysis summary. For the system considered, the summary contains the information, shown below, which describes the employed rule graph.
% \begin{figure}[H]
\begin{center}
    \begin{minted}[style=bw]{bash}
        rule graph : nodes : [ 1;2;3 ]
        arrows : [ (1,s,3,1);(2,s,3,3) ]
    \end{minted}
%     \caption{}
%     \label{fig:kdsljsssmkkggnn}
% \end{figure}
\end{center}
% in Figure~\ref{fig:kdsljsssmkkggnn},  
The ruler-graph is illustrated below.
%  in Figure~\ref{fig:dkgnnnaqqmmamnv}.
% \begin{figure}[H]
%     \centering
\begin{center}
    \resizebox{0.2\textwidth}{!}{
        \begin{tikzpicture}
                \graphbox{$L$}{0mm}{0mm}{35mm}{35mm}{2mm}{-5mm}{
                        \coordinate (delta) at (0,-18mm);
                        \node[draw,circle] (l1) at ($(delta)+(-1,1.5)$) {1};
                        \node[draw,circle] (l2) at ($(delta)+(1,1.5)$) {2};
                        \node[draw,circle] (l3) at ($(delta)+(0,0)$) {3};
                        \draw[->] (l1) -- (l3) node[midway,left] {$s$};
                        \draw[->] (l2) -- (l3) node[midway,right] {$s$};
                }
        \end{tikzpicture}
    }
%     \caption{}
%     \label{fig:dkgnnnaqqmmamnv}
% \end{figure}
    \end{center}

\subsection{Termination Analysis using the Morphism Counting with Antipattern}
Consider the graph rewriting system shown in Example~\ref{antipattern:ex:grs_aca}, whose termination cannot be proven either by the morphism counting method without forbidden patterns introduced in Chapter~\ref{chap:subgraph_counting} or by the subgraph counting method presented in~\cite{overbeek2024termination_lmcs}. Its unique rule is illustrated below.
%  in Figure~\ref{fig:intro:graph_transformation_rule_anti_pattern___}.
%  \begin{figure}[H]
%     \centering
\begin{center}
\begin{tikzpicture}
      \graphbox{$L$}{0mm}{0mm}{34mm}{20mm}{2mm}{-5mm}{
          \coordinate (o) at (0mm,-3mm); 
          \node[draw,circle] (l1) at ($(o)+(-10mm,0mm)$) {1};
          \node[draw,circle] (l2) at ($(l1)+(2,0)$) {2};
          \node[draw,circle] (l3) at ($(l1)+(1,0)$) {3};
          \draw[->] (l1) -- (l3) node[midway,above] {$a$};
          \draw[->] (l3) -- (l2) node[midway,above] {$a$};
      }     
      \graphbox{$K$}{40mm}{0mm}{24mm}{20mm}{2mm}{-5mm}{
          \coordinate (o) at (5mm,-3mm); 
          \node[draw,circle] (l1) at ($(o)+(-10mm,0mm)$) {1}; 
          \node[draw,circle] (l2) at ($(l1)+(1,0)$) {2};
      }    
      \graphbox{$R$}{70mm}{0mm}{45mm}{20mm}{2mm}{-5mm}{
        \coordinate (o) at (0mm,-3mm); 
        \node[draw,circle] (l1) at ($(o)+(-10mm,0mm)$) {1};
        \node[draw,circle] (l2) at ($(l1)+(2,0)$) {2};
        \node[draw,circle] (l3) at ($(l1)+(1,0)$) {3};
        \draw[->] (l1) -- (l3) node[midway,above] {$a$};
        \draw[->] (l3) -- (l2) node[midway,above] {$a$};
        \draw[->] (l3) edge [loop below] node {$c$} (l3);
      }    

      \node () at (37mm,-10mm) {$\leftarrowtail$};
      \node () at (67mm,-10mm) {$\rightarrowtail$};
  \end{tikzpicture}
%   \caption{}
%   \label{fig:intro:graph_transformation_rule_anti_pattern___}
%  \end{figure}
\end{center}
The rule is predefined in the tool and can be selected with the REPL command:
 \begin{minted}[style=bw]{bash}
   >> select_system_by_name bruggink14_ex1
 \end{minted}
The REPL provides the command \colorbox{Ivory2}{$rulergraphs$} to list available ruler-graphs. User-defined ruler-graphs can be added to this list using the method presented in the previous section. The ruler-graph shown in Figure~\ref{fig:implemented:ruler_graph_representation} is predefined in the tool and appears in the list of available ruler-graphs.

The ruler-graph shown in Figure~\ref{fig:implemented:ruler_graph_representation} is predefined and can be selected with the REPL command:
 \begin{minted}[style=bw]{bash}
   >> select_ruler_graph aa_not_in_aca
 \end{minted}
To analyse the system's relative termination using the morphism counting method with a forbidden pattern (see Chapter~\ref{chap:antipattern}) with the ruler-graph, run:
 \begin{minted}[style=bw]{bash}
   >> subgraph_counting_one_forbidden_context
\end{minted}
The following command displays a summary of the termination analysis.
 \begin{minted}[style=bw]{bash}
   >> recap
\end{minted} 
The message displayed contains \colorbox{Ivory2}{$Terminating:\ yes$}, which shows that the method applied successfully proved the relative termination of the rule with respect to the empty set of rules.

\subsection{Termination Analysis using the Type Graph Method}
Consider the rewriting rule shown below:
% in Figure~\ref{fig:implemented:grsaa_0ssssdfss}.
% \begin{figure}[H]
%       \centering 
\begin{center}
      \resizebox{0.8\textwidth}{!}{
      \begin{tikzpicture}
          \graphbox{$L$}{0mm}{0mm}{34mm}{15mm}{2mm}{-5mm}{
              \coordinate (o) at (0mm,-3mm); 
              \node[draw,circle] (l1) at ($(o)+(-10mm,0mm)$) {1};
              \node[draw,circle] (l2) at ($(l1)+(2,0)$) {2};
              \node[draw,circle] (l3) at ($(l1)+(1,0)$) {3};
              \draw[->] (l1) -- (l3) node[midway,above] {$a$};
              \draw[->] (l3) -- (l2) node[midway,above] {$a$};
          }     
          \graphbox{$K$}{40mm}{0mm}{24mm}{15mm}{2mm}{-5mm}{
              \coordinate (o) at (5mm,-3mm); 
              \node[draw,circle] (l1) at ($(o)+(-10mm,0mm)$) {1};
              \node[draw,circle] (l2) at ($(l1)+(1,0)$) {2};
              % \node[draw,circle] (l3) at ($(l1)+(1,0)$) {$\ $};
              % \draw[->] (l1) -- (l3) node[midway,above] {$a$};
              % \draw[->] (l3) -- (l2) node[midway,above] {$a$};
          }    
          \graphbox{$R$}{70mm}{0mm}{45mm}{15mm}{2mm}{-5mm}{
              \coordinate (o) at (-5mm,-3mm); 
              \node[draw,circle] (l1) at ($(o)+(-10mm,0mm)$) {1};
              \node[draw,circle] (l2) at ($(l1)+(3,0)$) {2};
              \node[draw,circle] (l3) at ($(l1)+(1,0)$) {4};
              \node[draw,circle] (l4) at ($(l1)+(2,0)$) {5};
              \draw[->] (l1) -- (l3) node[midway,above] {$a$};
              \draw[->] (l3) -- (l4) node[midway,above] {$b$};
              \draw[->] (l4) -- (l2) node[midway,above] {$a$};
          }    
          \node () at (37mm,-8mm) {$\overset{l}{\leftarrowtail}$};
          \node () at (67mm,-8mm) {$\overset{r}{\rightarrowtail}$};
          % \draw[>->] (51mm,2mm) -- (52mm,3mm);
      \end{tikzpicture}
      }
%       \caption{}
%       \label{fig:implemented:grsaa_0ssssdfss}
%   \end{figure}
    \end{center}
The following command selects this system.
 \begin{minted}[style=bw]{bash}
   >> select_system_by_name bruggink14_ex_4_and_6
\end{minted}
The following command shows relative termination of some non-empty subset of rules of the system with respect to the set of the remaining rules using the type graph method with the natural arithmetic semiring. The timeout is set to 30 seconds.
 \begin{minted}[style=bw]{bash}
   >> type_graph 30 n
\end{minted}
This command is an instance of the following command pattern
\begin{minted}[style=bw]{bash}
    type_graph [timeout] [semiring_1 semiring_2 ...]
\end{minted}
From the command pattern, we can see that more semirings can be selected. In fact, there are 6 semirings available in the tool, which can be selected by adding flags in the set $\set{a,t,n,A,T,N}$ where $A$, $T$, $N$ stand for the arctic, tropical, and arithmetic semirings over the (extended) natural numbers;  $a$, $t$, $n$ stand for the arctic, tropical, and arithmetic semirings over the (extended) real numbers. If multiple semirings are selected, the tool runs the type graph method in parallel for each chosen semiring. When some rules are removed the tool automatically starts a new iteration on the remaining rules using the same selected semirings. 

For example, we can have the following command which launches the type graph method with the timeout set to 30 seconds and all 6 available semirings.
\begin{minted}[style=bw]{bash} 
    >> type_graph 30 a n t A N T
\end{minted}
Type graph method with different semirings will be launched in parallel and cooperate with each other. When a non-empty subset $A$ of rules is proved to be terminating relative to the set of remaining rules $B$, a new iteration starts with the set of rules $B$.

The command \colorbox{Ivory2}{$recap$} displays a summary of the termination analysis. The summary contains \colorbox{Ivory2}{$Terminating:\ yes$} and \colorbox{Ivory2}{$Remaining\ Rules:\ none$}, showing that the method successfully proved the rule's relative termination with respect to the empty rule set.
The summary contains also the information shown below.
%  in Figure~\ref{fig:implemented:type_graph_summarydfsaldkfjsdl}. 
% \begin{figure}[H]
\begin{center}
    \begin{minted}[style=bw]{bash} 
        1 rule eliminated : rule 0 
        0 rule remaind : None

        0--a->0 : 0.0
        1--a->1 : 1.0/4.0 
        0--a->1 : 0.0
        0--b->0 : 1.0/16.0 
        1--a->0 : 1.0/8.0 

        0--a->0 : 0
        1--a->1 : 4
        0--a->1 : 0
        0--b->0 : 1
        1--a->0 : 2
    \end{minted}
%     \caption{}
%     \label{fig:implemented:type_graph_summarydfsaldkfjsdl}
% \end{figure}
\end{center}
The first block indicates that the rule whose representation is indexed by \colorbox{Ivory2}{0} (here the system's unique rule) can be eliminated using the type graph method over the real arctic semiring; no rules remain to be analyzed. The second block gives the information for constructing the type graph: two nodes and 5 edges with rational weights. The third block shows an equivalent type graph with integer weights obtained by multiplying the rational weights by their least common multiple. These type graphs are shown below:
% in Figure~\ref{fig:implemented:type_gdfdgggggg}.
%  \begin{figure}[H]
%     \centering
\begin{center}
    \resizebox{0.6\textwidth}{!}{
    \begin{tikzpicture}
      \graphbox{$L$}{20mm}{0mm}{45mm}{25mm}{2mm}{-5mm}{
          \coordinate (o) at (3mm,-4mm); 
          \node[draw,circle] (l0) at ($(o)+(-10mm,0mm)$) {$0$};
          \node[draw,circle] (l1) at ($(l0)+(2,0)$) {$1$};
            \draw[->] (l0) edge [loop below] node {$a^{0.0}$} (l0);
            \draw[->] (l0) edge [loop left] node {$b^{\frac{1.0}{16.0}}$} (l0);
            \draw[->] (l1) edge [loop below] node {$a^{\frac{1.0}{4.0}}$} (l1);
          \draw[->] (l0) to[bend left] node[midway,above] {$a^{0.0}$} (l1) ;
          \draw[->] (l1) to[bend left] node[midway,below] {$a^{\frac{1.0}{8.0}}$} (l0) ;
      }        
      \graphbox{$F$}{70mm}{0mm}{45mm}{25mm}{2mm}{-5mm}{
          \coordinate (o) at (3mm,-4mm); 
          \node[draw,circle] (l0) at ($(o)+(-10mm,0mm)$) {$0$};
          \node[draw,circle] (l1) at ($(l0)+(2,0)$) {$1$};
            \draw[->] (l0) edge [loop below] node {$a^{0}$} (l0);
            \draw[->] (l0) edge [loop left] node {$b^{1}$} (l0);
            \draw[->] (l1) edge [loop below] node {$a^{4}$} (l1);
          \draw[->] (l0) to[bend left] node[midway,above] {$a^{0}$} (l1) ;
          \draw[->] (l1) to[bend left] node[midway,below] {$a^{2}$} (l0);
      }    
    %   \node () at (37mm,-10mm) {$\leftarrowtail$};
      \node () at (67mm,-10mm) {$\rightarrowtail$};
  \end{tikzpicture}
    }
%   \caption{}
%   \label{fig:implemented:type_gdfdgggggg}
%  \end{figure}
\end{center}


% The system can be selected by using the command \colorbox{Ivory2}{select 3} which select the system with number \textit{3}. The REPL will display the following message to confirm the selection:
% \begin{center}
%     \colorbox{Ivory2}{$bruggink\_2014\_ex\_4\_and\_6$ selected}
% \end{center}

\section{Availability and license}

LyonParallel is available at \url{https://github.com/Qi-tchi/LyonParallel/tree/thesis}. The project is distributed under the LGPL-2.1 License.