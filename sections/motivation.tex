
% \paragraph{Ensuring the correctness of distributed algorithms is crucial} Distributed algorithms play an important role in our modern society. For example, they control machines that we use in daily basis such as smart phone but also critical systems such as medical devises, trains, airplanes, spaceship. Errors in distributed algorithms can have severe consequences, such as the loss of critical data or even the loss of human lives. 


% \paragraph{Ensuring the correctness of distributed algorithms is challenging}
% It is challenging to ensure the correctness of distributed algorithms.

% \paragraph{Interactive theorem proving can be used to ensure the correctness of distributed algorithms, but they are too demanding for most users}
% Formal methods can address this challenge by rigorous mathematical methods. Among these methods, mechanically verified proofs using proof assistants can provide a high level of assurance in the correctness of distributed algorithms.
% However, this approach is too demanding for most users, as they require a high level of expertise and are often time consuming.  

% \paragraph{Automated tools that check specific properties of distributed algorithms can alleviate the problem}
% Automated tools that check specific properties of distributed algorithms and can generate certificates that can be checked by proof assistants alleviate this problem: they can be used by users who are not experts in formal methods, and they can also speed up the verification process for experts. 

\paragraph{Distributed algorithms and their correctness}
Distributed systems play a crucial role in improving performance, 
scalability, and efficiency in modern computing.
For example, they control machines that we use in daily basis such as smart phone but also critical systems such as medical devises, trains, airplanes, spaceship. Errors in distributed algorithms can have severe consequences, such as the loss of critical data or even the loss of human lives. 
Ensuring their correctness is vital but challenging due to the inherent complexity of these systems~\cite{heiser2010theroad, lamport2019thebyzantine}.

\paragraph{Automated methods for verifying distributed algorithms}
While interactive theorem proving~\cite{harrison2014history} offers a promising approach to formally verifying properties of distributed systems~\cite{plump2024formalisingDPO,potop2019formal,courtieu2016certified},  
it requires proficiency in proof assistants and can be
time-consuming. Automated methods that check specific properties of distributed algorithms and can generate certificates that can be checked by proof assistants provide a practical alternative~\cite{contejean2011automated,giesl2014proving}: while they can only be applied to specific properties for some classes of distributed algorithms, they can be used by users who are not experts in formal methods, and they can also speed up the verification process for experts. To develop such automated methods, distributed algorithms need to be modeled in a formal way enabling rigorous analysis and automated verification of their properties.


 \paragraph{Graph transformation systems}
 Graph transformation systems provide an intuitive yet formal way to model distributed algorithms: computation units are represented by nodes; communication canals are represented by arrows; the working environment is modeled by a graph; arrows have labels representing information encoded in computation units and states of communication canals; system behavior expressed by state changes is modeled by replacing subgraphs in the graph by other subgraphs.

 The main stream approach is called algebraic graph rewriting. One of the advantages of algebraic graph rewriting is that it is defined up to isomorphism, which simplifies reasoning. 
  To transform a host graph $G$ using a rule which replaces an occurrence of a graph $L$ in $G$ by a graph $R$, one needs to decompose the graph $G$ into $C$ and $L$, remove $L$ and then connect $R$ to $C$ to form the result graph. Difference approaches to remove $L$ and connect $R$ to $C$ lead to different graph rewriting systems. 
  
  The most popular graph rewriting systems are:
   DPO, SPO, SqPO, Agree, PBPO, PBPO+. (to do develop)

we focus on DPO graph rewriting systems (to do why)
DPO rewriting systems are the most popular graph rewriting systems. It is very strict in the sense that no implicit edge deletion is allowed and it does not allow to duplicate nodes (to double check). While it has its limite in expressiveness, it is still powerful enough to model many distributed algorithms and provide a simple formalism easier to develop termination techniques.

\paragraph{Relative Termination of DPO graph rewriting systems}
We focus on relative termination of DPO graph rewriting systems. Given two rule sets \( \mathcal{A} \) and \( \mathcal{B} \), relative termination ensures that, for any graph finite graph $G$,
rules in $\mathcal{A}$ can only be applied finitely many times in any sequence of rule applications from $\mathcal{A} \cup \mathcal{B}$. 


\paragraph{DPO graph rewriting systems on edge-labeled directed multigraphs}
We focus on DPO graph rewriting systems on edge-labeled directed multigraphs.

\paragraph{Existing techniques for termination of DPO graph rewriting systems}
(to do to do)
There are not many techniques available.
 
\begin{itemize}
    \item Overbeek and Endrullis have developed a termination technique for PBPO+ graph rewriting systems~\cite{overbeek2024termination_lmcs}. This technique counts counts the number of occurrences of certain subgraphs before and after a rewriting steps. This technique can be applied to PBPO+ graph rewriting systems on many categories including edge-labeled directed multigraphs. It can also be applied to left-injective DPO graph rewriting systems.
    \item The type graph method, which weighs an object by summing the weights of morphisms from the object to a type graph, was initially introduced by Zantema, K{\"o}nig and Bruggink \cite{zantema2014termination} for cycle-rewriting systems. 
    This method has since been generalized to edge-labeled multigraphs by Bruggink et al. \cite{bruggink2014termination} for DPO rewriting with monic matches and injective rules, later extended to DPO rewriting in general by Bruggink et al. \cite{bruggink2015proving}, and further adapted to more categories and different DPO variants by Endrullis et al. \cite{endrullis2024generalized_arxiv_v2}. 
    \item Plump \cite{plump1995ontermination} introduced a necessary and sufficient termination condition for left-injective DPO hypergraph rewriting via forward closure, though verifying this condition is undecidable. 
    \item Plump \cite{plump2018modular} later proposed a modular critical pair-based strategy for left-injective DPO hypergraph rewriting with monic matches. 
    \item Levendovszky et al. \cite{levendovszky2007termination} propose a termination criterion for DPO rewriting (monic matches, injective rules, negative application condition), though automated verification is hard as explained in \cite[\textsection 6]{levendovszky2007termination}. 
    \item Bottoni et al. \cite{bottoni2005termination} propose a termination criterion for DPO/SPO rewriting on high-level replacement units. Their method imposes a strongly constrained measuring function and the only concretes measuring function proposed are node-counting and edge-counting.
    \item Bottoni et al. \cite{bottoni2010atermination} presents a criterion for termination of DPO rewriting with monic matches, injective rules and negative application conditions, based on the construction of a labeled transition system. 
\end{itemize}

\textcolor{red}{todo :adapt section related work in \autoref{chap:nwf_type_graph} and \autoref{chap:subgraph_counting}}

\paragraph{Position of our work}
\begin{description}
    \item[general introduction] We extend the type graph method to non-well-founded semirings and develop a termination technique for injective DPO graph rewriting systems on edge-labeled directed multigraphs using subgraph counting.
    \item[our general philosphy] Different from the philosphy of Overbeek and Endrullis, we focus on 
developping specific termination techniques for DPO graph rewriting systems on
edge-labeled directed multigraphs, which are graphs with directed edges that can have multiple edges between two nodes and edges can have labels. These techniques cannot be applied to other categories in general, for some of them, they can be applied with some minor modifications. This choice is motivated by the fact that developping termination techniques is a difficult task, we want more arguments specific to DPO graph rewriting systems on edge-labeled directed multigraphs be available in the process of developing termination techniques. Another reason is that we want our techniques easy to be understood: to understand our techniques, only undergraduate knowledge in graph theory and some basic knowledge in category theory are required. The second reason is important because in our opinion, automated tools are not only for experts, and non experts should be able to easily understand the techniques and are not supposed to be experts in category theory. 
\end{description}


\paragraph{Contribution 1 : an extension of Type Graph Method to non-well-founded semirings} While the type graph method is a powerful termination technique for DPO graph rewriting systems, previous approaches use weighted type graphs over well-founded semirings, which have practical limitations when applied to edge-labeled directed multigraph rewriting. In \autoref{chap:nwf_type_graph}, we investigate the use of non-well-founded semirings to overcome these limitations. This is a step towards a more practical termination technique.
We have implemented both our method and the prior approach by Endrullis and Overbeek~\cite{overbeek2024termination_lmcs} for edge-labeled graph rewriting within a unified tool.

\autoref{chap:nwf_type_graph} is based on the following paper:
\textcolor{red}{ref}
 
\paragraph{Contribution 2 : a termination technique for injective DPO graph rewriting systems on edge labeled directed multigraphs using subgraph counting}
\autoref{chap:subgraph_counting} is based on the following paper:
\begin{itemize}
    \item Qiu, Q. (2025). Termination of Injective DPO Graph Rewriting Systems Using Subgraph Counting. In: Endrullis, J., Tichy, M. (eds) Graph Transformation. ICGT 2025. Lecture Notes in Computer Science, vol 15720. Springer, Cham. \url{https://doi.org/10.1007/978-3-031-94706-3_1}
\end{itemize}
