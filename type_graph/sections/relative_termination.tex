% \todo{plus generalement, c'est defini sur des relations, pas forcement de reecriture}
% \begin{definition} 
%     Let \(\mathcal{R}\) be a set of rewriting rules and let $\mathfrak{F}$ be a DPO rewriting framework.
%     An \textbf{$(\mathcal{R},\mathfrak{F})$-rewriting sequence} is either  
%     \begin{itemize}
%         \item a finite sequence \(s_0,s_1,\hdots, s_m\) of objects such that \( s_n \mathop{\Rightarrow}_{\mathcal{R},\mathfrak{F}} s_{n+1}\text{ for each } 0 \leq n \leq m-1\), or
%         \item an infinite sequence \(s_0,s_1,\hdots\) of objects such that \(s_n \mathop{\Rightarrow}_{\mathcal{R},\mathfrak{F}} s_{n+1}\) for each \(n \mathop{\in} \mathbb{N}\).
%     \end{itemize}
%     An $(\mathcal{R},\mathfrak{F})$-rewriting sequence from \( s_0 \) will be denoted by:
%     \[
%     s_0 \mathop{\Rightarrow}_{\mathcal{R},\mathfrak{F}} s_1 \mathop{\Rightarrow}_{\mathcal{R},\mathfrak{F}} s_2 \mathop{\Rightarrow}_{\mathcal{R},\mathfrak{F}} \cdots 
%     \]
% \end{definition}
Given a DPO rewriting framework \(\mathfrak{F}\), a rule set \(\mathcal{R}\) defines the binary relation \enquote{object $X$ can be rewritten to object $Y$ using rules from the rule set} on the objects of the category $\mathcal{C}$.
\begin{definition}\label{def:rewriting-chain}
Let \(\mathcal{R}\) be a rule set and let \(\mathfrak{F}\) be a DPO rewriting framework.
An \textbf{\((\mathcal{R},\mathfrak{F})\)-rewriting chain}\index{Rewriting chain} is a \(\mathop{\Rightarrow}_{\mathcal{R},\mathfrak{F}}\)-chain.

When the context is clear, we simply call it a \textbf{rewriting chain}.
\end{definition}

\begin{example}
    \label{example:preliminaries:dggdfgnkfsjksfkjsf}
    Consider the rewriting rule below. It replaces an occurrence of the graph 
\raisebox{2pt}{
            \scalebox{0.7}{\tikz[baseline=-0.5ex]{
            \node [draw,circle] (z) at (-1,0) {};
            \node [draw,circle] (x) at (0,0) {};
            \node[draw,circle] (y) at (1,0) {};
            \draw[->] (z)--(x) node[midway, above] {$a$};
            \draw[->] (x)--(y) node[midway, above] {$b$};
        }}} with an occurrence of the graph \raisebox{2pt}{
            \scalebox{0.7}{\tikz[baseline=-0.5ex]{
            \node [draw,circle] (z) at (-1,0) {};
            \node [draw,circle] (x) at (0,0) {};
            \node[draw,circle] (y) at (1,0) {};
            \draw[->] (z)--(x) node[midway, above] {$b$};
            \draw[->] (x)--(y) node[midway, above] {$a$};
        }}}, keeping the extreme nodes unchanged.

        \vspace{-5mm}
    \begin{center}
            \resizebox{\textwidth}{!}{
                \begin{tikzpicture} 
                    \graphbox{\( L \)}{0mm}{-3mm}{34mm}{15mm}{2mm}{2mm}{
                        \coordinate (o) at (0mm,-11mm); 
                        \node[draw,circle] (l1) at ($(o)+(-10mm,0mm)$) {1};
                        \node[draw,circle] (l2) at ($(l1)+(2,0)$) {2};
                        \node[draw,circle] (l3) at ($(l1)+(1,0)$) {3};
                        \draw[->] (l1) -- (l3) node[midway,above] {$a$};
                        \draw[->] (l3) -- (l2) node[midway,above] {$b$};
                    } 
            
                    \graphbox{\( K \)}{40mm}{-3mm}{34mm}{15mm}{2mm}{2mm}{
                        \coordinate (o) at (0mm,-11mm); 
                        \node[draw,circle] (l1) at ($(o)+(-10mm,0mm)$) {1};
                        \node[draw,circle] (l2) at ($(l1)+(2,0)$) {2};
                    }  
            
                    \graphbox{\( R \)}{80mm}{-3mm}{35mm}{15mm}{2mm}{2mm}{
                        \coordinate (o) at (0mm,-11mm); 
                        \node[draw,circle] (l1) at ($(o)+(-10mm,0mm)$) {1};
                        % \node[draw,circle] (l2) at ($(l1)+(3,0)$) {2};
                        \node[draw,circle] (l3) at ($(l1)+(1,0)$) {4};
                        \node[draw,circle] (l4) at ($(l1)+(2,0)$) {2};
                        \draw[->] (l1) -- (l3) node[midway,above] {$b$};
                        \draw[->] (l3) -- (l4) node[midway,above] {$a$};
                        % \draw[->] (l4) -- (l2) node[midway,above] {$a$};
                    }    
                    \node () at (37mm,-10mm) {\( \leftarrowtail \)}; % K -> L
                    \node () at (77mm,-10mm) {\( \rightarrowtail \)}; % K -> R
                \end{tikzpicture}
                }
    %     \caption{}
    %     \label{fig:preliminaries:graph_transformation_rule_nonterminating}
    % \end{figure} 
            \end{center} 

    A looping rewriting chain using this rule can be the following, to be read left to right. In each graph, the subgraph to be replaced to obtain the next graph is highlighted in red.

    \vspace{-2mm}
        \begin{figure}[H]
           \centering
         \resizebox{\textwidth}{!}{
            \begin{tikzpicture}
            \graphbox{\( \)}{0mm}{0mm}{20mm}{20mm}{-5mm}{-14mm}{
                \node[draw,circle] (x) at (0,0) {};
                \node[draw,circle] (y) at (1,0) {};
                \node[draw,circle] (z) at (0.5,0.86) {};
                \draw[->,red] (x) -- node[midway,below] {$a$} (y) ;
                \draw[->,red] (y) -- node[midway,right] {$b$} (z) ;
                \draw[->] (z) -- node[midway,left] {$b$} (x) ;
            } 
            \node () at (25mm,-10mm) {\( \Rightarrow \)};
            \graphbox{\( \)}{30mm}{0mm}{20mm}{20mm}{-5mm}{-14mm}{
                \node[draw,circle] (x) at (0,0) {};  
                \node[draw,circle] (y) at (1,0) {};
                \node[draw,circle] (z) at (0.5,0.86) {};
                \draw[->] (x) -- node[midway,below] {$b$} (y) ;
                \draw[->,red] (y) -- node[midway,right] {$a$} (z) ;
                \draw[->,red] (z) -- node[midway,left] {$b$} (x) ;
            }
            \node () at (55mm,-10mm) {\( \Rightarrow  \)};
            \graphbox{\( \)}{60mm}{0mm}{20mm}{20mm}{-5mm}{-14mm}{
                \node[draw,circle] (x) at (0,0) {};  
                \node[draw,circle] (y) at (1,0) {};
                \node[draw,circle] (z) at (0.5,0.86) {};
                \draw[->,red] (x) -- node[midway,below] {$b$} (y) ;
                \draw[->] (y) -- node[midway,right] {$b$} (z) ;
                \draw[->,red] (z) -- node[midway,left] {$a$} (x) ;
            }
            \node () at (85mm,-10mm) {\( \Rightarrow  \)};
            \graphbox{\( \)}{90mm}{0mm}{20mm}{20mm}{-5mm}{-14mm}{
                \node[draw,circle] (x) at (0,0) {};   
                \node[draw,circle] (y) at (1,0) {};
                \node[draw,circle] (z) at (0.5,0.86) {};
                \draw[->,red] (x) -- node[midway,below] {$a$} (y) ;
                \draw[->,red] (y) -- node[midway,right] {$b$} (z) ;
                \draw[->] (z) -- node[midway,left] {$b$} (x) ;
            }
         \end{tikzpicture}
        }
        \end{figure}
\end{example}


For a set of rewriting rules \(\mathcal{R}\) (and a DPO rewriting framework \(\mathfrak{F}\)), the impossibility of transforming any object indefinitely with the non-deterministic strategy \enquote{apply rules as long as possible} using rules from \(\mathcal{R}\) (in the framework \(\mathfrak{F}\)) is called \emph{termination}~\cite{middeldorp1997simple}. This property corresponds to program termination on all inputs in conventional programming languages, and is undecidable in general~\cite{plump1998terminationundecidable}.

For example of a non-terminating rule set, consider the set consisting of the rule and the infinite rewriting chain in Example~\ref{example:preliminaries:dggdfgnkfsjksfkjsf}.
For example of a terminating rule set, consider the set with the unique rule, shown below,
which relabels an edge. 

     \resizebox{0.9\textwidth}{!}{ 
                \begin{tikzpicture}
                    \graphbox{\( L \)}{0mm}{-3mm}{34mm}{15mm}{2mm}{2mm}{
                        \coordinate (o) at (0mm,-11mm); 
                        \node[draw,circle] (l1) at ($(o)+(-10mm,0mm)$) {1};
                        \node[draw,circle] (l2) at ($(l1)+(2,0)$) {2};
                        % \node[draw,circle] (l3) at ($(l1)+(1,0)$) {3};
                        \draw[->] (l1) -- (l2) node[midway,above] {$a$};
                    } 
            
                    \graphbox{\( K \)}{40mm}{-3mm}{34mm}{15mm}{2mm}{2mm}{
                        \coordinate (o) at (0mm,-11mm); 
                        \node[draw,circle] (l1) at ($(o)+(-10mm,0mm)$) {1};
                        \node[draw,circle] (l2) at ($(l1)+(2,0)$) {2};
                    }  
            
                    \graphbox{\( R \)}{80mm}{-3mm}{35mm}{15mm}{2mm}{2mm}{
                        \coordinate (o) at (0mm,-11mm); 
                        \node[draw,circle] (l1) at ($(o)+(-10mm,0mm)$) {1};
                        % \node[draw,circle] (l2) at ($(l1)+(3,0)$) {2};
                        % \node[draw,circle] (l3) at ($(l1)+(1,0)$) {4};
                        \node[draw,circle] (l4) at ($(l1)+(2,0)$) {2};
                        \draw[->] (l1) -- (l4) node[midway,above] {$b$};
                        % \draw[->] (l4) -- (l2) node[midway,above] {$a$};
                    }    
                    \node () at (37mm,-10mm) {\( \leftarrowtail \)}; % K -> L
                    \node () at (77mm,-10mm) {\( \rightarrowtail \)}; % K -> R
                \end{tikzpicture}
                }
                
Any rewriting chain using this rule is finite, because each rewriting step decreases the number of edges by one and a graph has only a finite number of edges by definition.

However, in many cases, an interesting property can be proved even if the whole rule set is not terminating. 
Take the system with rules $\alpha$ and $\beta$ shown below. Rule~$\alpha$ removes one edge per application; rule~$\beta$ introduces a new node. 
\begin{center}
        $\alpha$ = { 
             \resizebox{0.9\textwidth}{!}{
             \begin{tikzpicture}[baseline=-0.065\textheight]
                    \graphbox{\( \mathcal{L} \)}{0mm}{-3mm}{34mm}{15mm}{2mm}{2mm}{
                        \coordinate (o) at (0mm,-11mm); 
                        \node[draw,circle] (l1) at ($(o)+(-10mm,0mm)$) {$1$};
                        \node[draw,circle] (l2) at ($(l1)+(2,0)$) {$2$};
                        \draw[->] (l1) -- (l2) node[midway,above] {};
                    } 
            
                    \graphbox{\( \mathcal{K} \)}{40mm}{-3mm}{34mm}{15mm}{2mm}{2mm}{
                        \coordinate (o) at (0mm,-11mm); 
                        \node[draw,circle] (l1) at ($(o)+(-10mm,0mm)$) {$1$};
                        \node[draw,circle] (l2) at ($(l1)+(2,0)$) {$2$};
                    }  
            
                    \graphbox{\( \mathcal{R} \)}{80mm}{-3mm}{35mm}{15mm}{5mm}{2mm}{
                        \coordinate (o) at (-5mm,-11mm); 
                        \node[draw,circle] (l1) at ($(o)+(-10mm,0mm)$) {$1$};
                        \node[draw,circle] (l4) at ($(l1)+(2,0)$) {$2$};
                    }    
                    \node () at (37mm,-10mm) {\( \leftarrowtail \)}; % K -> L
                    \node () at (77mm,-10mm) {\( \rightarrowtail \)}; % K -> R
                \end{tikzpicture}
            }
        }

\vspace{2mm}
        $\beta$ ={
             \resizebox{0.9\textwidth}{!}{
             \begin{tikzpicture}[baseline=-0.065\textheight]
                    \graphbox{\( \mathcal{L} \)}{0mm}{-3mm}{34mm}{15mm}{2mm}{2mm}{
                        
                    } 
            
                    \graphbox{\( \mathcal{K} \)}{40mm}{-3mm}{34mm}{15mm}{2mm}{2mm}{
                       
                    }  
            
                    \graphbox{\( \mathcal{R} \)}{80mm}{-3mm}{35mm}{15mm}{5mm}{2mm}{
                        \coordinate (o) at (0mm,-11mm); 
                        \node[draw,circle] (l1) at ($(o)+(-10mm,0mm)$) {};
                    }    
                    \node () at (37mm,-10mm) {\( \leftarrowtail \)}; % K -> L
                    \node () at (77mm,-10mm) {\( \rightarrowtail \)}; % K -> R
                \end{tikzpicture}
            }
        }
    %     \caption{A graph transformation rule for node addition}
    %     \label{fig:intro:node_addition_rule}
    % \end{subfigure} 
            \end{center}
Because $\beta$ can always be re-applied to generate additional nodes, infinite rewriting sequences exist. Conversely, $\alpha$ is applicable only 
a finite number of times in any rewriting chain, since each application removes an edge and no rule adds edges. Since the initial graph is finite, the possibility of non-termination stems exclusively from $\beta$. This attribution illustrates the broader idea of \emph{relative termination} as introduced by Klop~\cite{klop1987term} and explored in~\cite{geser1990relative,kassing2024dependency,endrullis2024generalized_icgt,zantema2014termination,bruggink2014termination,bruggink2015proving}.
\begin{definition}
    \index{Relative termination!binary relation}
Let $A$ be a collection of objects and let $R$ and $S$ be binary relations on $A$. 
We say that $R$ is \textbf{terminating relative to} $S$ (or that $R$ \textbf{terminates relative to} $S$) if 
any $(R \mathop{\cup} S)$-chain contains only a finite number of $R$-steps.
In particular, $R$ is \textbf{terminating} (or terminates) if it is terminating relative to the empty relation $\emptyset$.
\end{definition}

For example, the relation $>$ on $\mathbb{N}$ is terminating relative to the empty relation, since any $(\mathop{>} \mathop{\cup} \emptyset)$-chain contains only a finite number of $>$-steps. The relation $>$ is also terminating relative to $\geq$ on $\mathbb{N}$, since any $(\mathop{>} \mathop{\cup} \mathop{\geq})$-chain can only contain a finite number of $>$-steps.

% Note that termination and well-foundedness are the same property of a binary relation $\to$ described from two perspectives. Operationally, we read $x \mathop{\to} y$ as \enquote{$x$ can be transformed to $y$}; the absence of infinite $\rightarrow$-chains therefore means that any transformation sequence starting from an initial object $x$ is finite, i.e. every computation or rewrite sequence eventually terminates. Structurally, we read $x \mathop{\to} y$ as \enquote{$x$ is constructed from $y$}; the absence of infinite $\to$-chains then implies that every object $x$ can be traced back along a finite chain to an element that is not constructed from any other, so the structure is well-founded. In this thesis we adopt the operational viewpoint and use the term termination.

Relative termination and termination
carries over to rewriting systems in a straightforward way via their associated rewriting relations.
\begin{definition}
    \label{termination:def:relative_termination}
    \index{Relative termination!rule-set}
     Let $\mathcal{R}$ and $\mathcal{S}$ be sets of rewriting rules and let $\mathfrak{F}$ be a DPO rewriting framework. 
     We say that 
     $\mathcal{R}$ is \textbf{terminating relative to} $\mathcal{S}$ 
     if 
     $\mathop{\Rightarrow}_{\mathcal{R},\mathfrak{F}}$ is terminating relative to $\mathop{\Rightarrow}_{\mathcal{S}, \mathfrak{F}}$.
\end{definition}
In practice, to prove termination of a set $\mathcal{R}$ of rules, one partitions $\mathcal{R}$ into two disjoint subsets \( \mathcal{B} \) and \( \mathcal{A} \) with non-empty $\mathcal{A}$ such that \( \mathcal{A} \) terminates relative to \( \mathcal{B} \). 
If $\mathcal{B}$ is empty then the termination of $\mathcal{R}$ is established, otherwise, a new iteration starts with the strictly smaller rule set $\mathcal{B}$.

Many techniques have been developed for proving termination of term rewriting systems~\cite{arts2000termination,nipkow1998term,contejean2011automated,contejean2005mechanically,dershowitz1982orderings,giesl2014proving,middeldorp1997simple,urbain2004modular,marche2004modular,steinbach1995simplification}.
Some of them can be adapted to prove relative termination, for example the polynomial interpretation method.
However, most of these techniques cannot be directly applied to graph rewriting systems.

One reason is that techniques for term rewriting systems often rely on the fact that terms are tree-like structures, while graphs are not.
For example, in the polynomial interpretation method, every n-ary function symbol \(f\) is associated with a polynomial \(P_f(X_1, X_2, \ldots, X_n)\) with coefficients in $\mathbb{N}$, so that ground terms are mapped to natural numbers. The system is guaranteed to terminate if, for every rewriting rule \(l \to r\), the polynomial interpretation of \(l\) is strictly greater than that of \(r\). For instance, consider the term rewriting rule $f(a,b) \to f(b,a)$. One could 
interpret the constants \(a\) and \(b\) as \(2\) and \(1\), respectively, and the function symbol \(f\) with the polynomial \(P_f(X_1, X_2) = 2X_1 + X_2\). Under this interpretation, \(f(a,b)\) has value \(5\) and \(f(b,a)\) has value \(4\), demonstrating strict decrease under this rule.

 A further complication stems from the presence of cycles in graphs, in contrast to terms, which are inherently acyclic. These cycles may allow graphs to be rewritten indefinitely, making standard termination arguments that rely on acyclicity ineffective.
For example, the term rewriting rule $f(a,b) \to f(b,a)$ is analogous to the graph rewriting rule:
\vspace{-2mm}
 \begin{center}
            \resizebox{\textwidth}{!}{
                \begin{tikzpicture}
                    \graphbox{\( L \)}{0mm}{-3mm}{34mm}{15mm}{2mm}{2mm}{
                        \coordinate (o) at (0mm,-11mm); 
                        \node[draw,circle] (l1) at ($(o)+(-10mm,0mm)$) {1};
                        \node[draw,circle] (l2) at ($(l1)+(2,0)$) {2};
                        \node[draw,circle] (l3) at ($(l1)+(1,0)$) {3};
                        \draw[->] (l1) -- (l3) node[midway,above] {$a$};
                        \draw[->] (l3) -- (l2) node[midway,above] {$b$};
                    } 
            
                    \graphbox{\( K \)}{40mm}{-3mm}{34mm}{15mm}{2mm}{2mm}{
                        \coordinate (o) at (0mm,-11mm); 
                        \node[draw,circle] (l1) at ($(o)+(-10mm,0mm)$) {1};
                        \node[draw,circle] (l2) at ($(l1)+(2,0)$) {2};
                    }  
            
                    \graphbox{\( R \)}{80mm}{-3mm}{35mm}{15mm}{2mm}{2mm}{
                        \coordinate (o) at (0mm,-11mm); 
                        \node[draw,circle] (l1) at ($(o)+(-10mm,0mm)$) {1};
                        % \node[draw,circle] (l2) at ($(l1)+(3,0)$) {2};
                        \node[draw,circle] (l3) at ($(l1)+(1,0)$) {4};
                        \node[draw,circle] (l4) at ($(l1)+(2,0)$) {2};
                        \draw[->] (l1) -- (l3) node[midway,above] {$b$};
                        \draw[->] (l3) -- (l4) node[midway,above] {$a$};
                        % \draw[->] (l4) -- (l2) node[midway,above] {$a$};
                    }    
                    \node () at (37mm,-10mm) {\( \leftarrowtail \)}; % K -> L
                    \node () at (77mm,-10mm) {\( \rightarrowtail \)}; % K -> R
                \end{tikzpicture}
                }
            \end{center} 
However, the term rewriting rule terminates, while the graph rewriting rule does not as shown in Example~\ref{example:preliminaries:dggdfgnkfsjksfkjsf}.

Therefore, termination techniques specific to graph rewriting systems are needed. 

\subsection{Termination Techniques in DPO Graph Rewriting}
We provide an overview of some existing techniques for proving (relative) termination of DPO rewriting systems.

The weighted type graph method was first introduced by Zantema, K{\"{o}}nig and Bruggink~(2014)~\cite{zantema2014termination} for proving relative termination of cycle rewriting. Their subsequent work in 2014~\cite{bruggink2014termination} generalized it for DPO rewriting on edge-labeled directed multigraphs with injective rules and injective matches; later, it was extended to general DPO rewriting on edge-labeled multigraphs by Bruggink et al.~(2015)~\cite{bruggink2015proving}; and it was adapted to broader categories and DPO variants by Endrullis and Overbeek~(2024)~\cite{endrullis2024generalized_icgt}.
It assigns a weight to each graph by aggregating the weights of all morphisms to a designated weighted type graph. 
The challenge consists in characterizing the type graphs and the computation of weights that guarantee a decrease in the weight of the graphs with each rule application.

The subgraph-counting method was developed by Overbeek and Endrullis~(2024)~\cite{overbeek2024termination_lmcs}.
It is designed for proving relative termination of PBPO+~(2023)~\cite{overbeek2023graph, overbeek2023apbpotutorial}\textemdash{}a rewriting formalism capable of simulating left-injective DPO rewriting.
This method assigns a weight to a graph by summing the weights of morphisms from a set of designated graphs into the target graph.
This method, 
 Additionally, this method can be applied for many different graph notions. 

Plump (1995)~\cite{plump1995ontermination} gives a necessary and sufficient termination criterion for left-injective DPO rewriting rules in terms of forward closure which are derivations satisfying certain property. A rewriting system is terminating if and only if it does not admit an infinite forward closure and for each rule $L \overset{l}{\leftarrow} K \overset{r}{\rightarrow} R$, $l$ is not surjective.
However, absence of infinite forward closures is undecidable, since this criterion is equivalent to termination of systems with non-surjective left morphisms.

Plump (2018)~\cite{plump2018modular} later proposed a modular critical pair-based strategy for left-injective DPO graph rewriting with monic matches.
It decomposes a rewriting system into two subsystems, each of which can be analyzed separately using arbitrary termination techniques, and if both subsystems terminate, then the termination of the whole system is guaranteed.
However, termination of the subsystems still needs to be established using some techniques.

Levendovszky et al.~(2007)~\cite{levendovszky2007termination} proposed a termination criterion for DPO rewriting with monic matches, injective rules and negative application conditions on finite typed attributed graphs. It is based on the fact that if the application of every infinite sequence of rules requires the initial graph to be infinite, then the system terminates. This technique is theoretically very interesting, but it is hard to check the termination condition automatically as explained in~\cite[\textsection 6]{levendovszky2007termination}. 

Bottoni et al.~(2005)~\cite{bottoni2005termination} present a termination criterion for DPO rewriting systems with very restrictive external control mechanisms. The method relies on a measuring function satisfying a very strong constraint, and the instance of such a measuring function proposed is node and edge counting which is subsumed by the subgraph-counting method and the weighted type graph method.

Bottoni et al.~(2010)~\cite{bottoni2010atermination} present a criterion for termination of DPO rewriting with monic matches, injective rules and negative application conditions, based on the construction of a labeled transition system.

In Chapter~\ref{chap:nwf}, we extend the weighted type graph method to facilitate the search for suitable type graphs and improve its usability.
 In Chapter~\ref{chap:subgraph_counting}, we present a new approach for proving relative termination of DPO rewriting systems based on morphism counting.

Motivated by the need for methods that are both usable and applicable to new cases, we advance the state of the art in two ways. Chapter~\ref{chap:nwf} extends the weighted type graph method to facilitate the search for suitable type graphs and to improve its usability, while Chapters~\ref{chap:subgraph_counting} and~\ref{chap:antipattern} present a morphism-counting approach that is incomparable with existing techniques and can tackle new cases.